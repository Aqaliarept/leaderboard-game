// Code generated by protoc-gen-grain. DO NOT EDIT.
// versions:
//  protoc-gen-grain v0.7.0
//  protoc           v5.28.0
// source: protos.proto

package cluster

import (
	fmt "fmt"
	actor "github.com/asynkron/protoactor-go/actor"
	cluster "github.com/asynkron/protoactor-go/cluster"
	proto "google.golang.org/protobuf/proto"
	slog "log/slog"
	time "time"
)

func ErrPlayerNotFound(format string, args ...interface{}) *cluster.GrainErrorResponse {
	return cluster.NewGrainErrorResponse(ErrorReason_PLAYER_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

func IsPlayerNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := cluster.FromError(err)
	return e.Reason == ErrorReason_PLAYER_NOT_FOUND.String()
}

func ErrPlayerAlreadyPlaying(format string, args ...interface{}) *cluster.GrainErrorResponse {
	return cluster.NewGrainErrorResponse(ErrorReason_PLAYER_ALREADY_PLAYING.String(), fmt.Sprintf(format, args...))
}

func IsPlayerAlreadyPlaying(err error) bool {
	if err == nil {
		return false
	}
	e := cluster.FromError(err)
	return e.Reason == ErrorReason_PLAYER_ALREADY_PLAYING.String()
}

func ErrPlayerNotPlaying(format string, args ...interface{}) *cluster.GrainErrorResponse {
	return cluster.NewGrainErrorResponse(ErrorReason_PLAYER_NOT_PLAYING.String(), fmt.Sprintf(format, args...))
}

func IsPlayerNotPlaying(err error) bool {
	if err == nil {
		return false
	}
	e := cluster.FromError(err)
	return e.Reason == ErrorReason_PLAYER_NOT_PLAYING.String()
}

var xPlayerFactory func() Player

// PlayerFactory produces a Player
func PlayerFactory(factory func() Player) {
	xPlayerFactory = factory
}

// GetPlayerGrainClient instantiates a new PlayerGrainClient with given Identity
func GetPlayerGrainClient(c *cluster.Cluster, id string) *PlayerGrainClient {
	if c == nil {
		panic(fmt.Errorf("nil cluster instance"))
	}
	if id == "" {
		panic(fmt.Errorf("empty id"))
	}
	return &PlayerGrainClient{Identity: id, cluster: c}
}

// GetPlayerKind instantiates a new cluster.Kind for Player
func GetPlayerKind(opts ...actor.PropsOption) *cluster.Kind {
	props := actor.PropsFromProducer(func() actor.Actor {
		return &PlayerActor{
			Timeout: 60 * time.Second,
		}
	}, opts...)
	kind := cluster.NewKind("Player", props)
	return kind
}

// GetPlayerKind instantiates a new cluster.Kind for Player
func NewPlayerKind(factory func() Player, timeout time.Duration, opts ...actor.PropsOption) *cluster.Kind {
	xPlayerFactory = factory
	props := actor.PropsFromProducer(func() actor.Actor {
		return &PlayerActor{
			Timeout: timeout,
		}
	}, opts...)
	kind := cluster.NewKind("Player", props)
	return kind
}

// Player interfaces the services available to the Player
type Player interface {
	Init(ctx cluster.GrainContext)
	Terminate(ctx cluster.GrainContext)
	ReceiveDefault(ctx cluster.GrainContext)
	Join(req *JoinRequest, ctx cluster.GrainContext) (*None, error)
	StartCompetition(req *StartCompetitionRequest, ctx cluster.GrainContext) (*None, error)
	WaitingExpired(req *None, ctx cluster.GrainContext) (*None, error)
	AddScores(req *AddScoresRequest, ctx cluster.GrainContext) (*None, error)
	CompleteCompetition(req *None, ctx cluster.GrainContext) (*None, error)
}

// PlayerGrainClient holds the base data for the PlayerGrain
type PlayerGrainClient struct {
	Identity string
	cluster  *cluster.Cluster
}

// Join requests the execution on to the cluster with CallOptions
func (g *PlayerGrainClient) Join(r *JoinRequest, opts ...cluster.GrainCallOption) (*None, error) {
	if g.cluster.Config.RequestLog {
		g.cluster.Logger().Info("Requesting", slog.String("identity", g.Identity), slog.String("kind", "Player"), slog.String("method", "Join"), slog.Any("request", r))
	}
	bytes, err := proto.Marshal(r)
	if err != nil {
		return nil, err
	}
	reqMsg := &cluster.GrainRequest{MethodIndex: 0, MessageData: bytes}
	resp, err := g.cluster.Request(g.Identity, "Player", reqMsg, opts...)
	if err != nil {
		return nil, fmt.Errorf("error request: %w", err)
	}
	switch msg := resp.(type) {
	case *None:
		return msg, nil
	case *cluster.GrainErrorResponse:
		if msg == nil {
			return nil, nil
		}
		return nil, msg
	default:
		return nil, fmt.Errorf("unknown response type %T", resp)
	}
}

// StartCompetition requests the execution on to the cluster with CallOptions
func (g *PlayerGrainClient) StartCompetition(r *StartCompetitionRequest, opts ...cluster.GrainCallOption) (*None, error) {
	if g.cluster.Config.RequestLog {
		g.cluster.Logger().Info("Requesting", slog.String("identity", g.Identity), slog.String("kind", "Player"), slog.String("method", "StartCompetition"), slog.Any("request", r))
	}
	bytes, err := proto.Marshal(r)
	if err != nil {
		return nil, err
	}
	reqMsg := &cluster.GrainRequest{MethodIndex: 1, MessageData: bytes}
	resp, err := g.cluster.Request(g.Identity, "Player", reqMsg, opts...)
	if err != nil {
		return nil, fmt.Errorf("error request: %w", err)
	}
	switch msg := resp.(type) {
	case *None:
		return msg, nil
	case *cluster.GrainErrorResponse:
		if msg == nil {
			return nil, nil
		}
		return nil, msg
	default:
		return nil, fmt.Errorf("unknown response type %T", resp)
	}
}

// WaitingExpired requests the execution on to the cluster with CallOptions
func (g *PlayerGrainClient) WaitingExpired(r *None, opts ...cluster.GrainCallOption) (*None, error) {
	if g.cluster.Config.RequestLog {
		g.cluster.Logger().Info("Requesting", slog.String("identity", g.Identity), slog.String("kind", "Player"), slog.String("method", "WaitingExpired"), slog.Any("request", r))
	}
	bytes, err := proto.Marshal(r)
	if err != nil {
		return nil, err
	}
	reqMsg := &cluster.GrainRequest{MethodIndex: 2, MessageData: bytes}
	resp, err := g.cluster.Request(g.Identity, "Player", reqMsg, opts...)
	if err != nil {
		return nil, fmt.Errorf("error request: %w", err)
	}
	switch msg := resp.(type) {
	case *None:
		return msg, nil
	case *cluster.GrainErrorResponse:
		if msg == nil {
			return nil, nil
		}
		return nil, msg
	default:
		return nil, fmt.Errorf("unknown response type %T", resp)
	}
}

// AddScores requests the execution on to the cluster with CallOptions
func (g *PlayerGrainClient) AddScores(r *AddScoresRequest, opts ...cluster.GrainCallOption) (*None, error) {
	if g.cluster.Config.RequestLog {
		g.cluster.Logger().Info("Requesting", slog.String("identity", g.Identity), slog.String("kind", "Player"), slog.String("method", "AddScores"), slog.Any("request", r))
	}
	bytes, err := proto.Marshal(r)
	if err != nil {
		return nil, err
	}
	reqMsg := &cluster.GrainRequest{MethodIndex: 3, MessageData: bytes}
	resp, err := g.cluster.Request(g.Identity, "Player", reqMsg, opts...)
	if err != nil {
		return nil, fmt.Errorf("error request: %w", err)
	}
	switch msg := resp.(type) {
	case *None:
		return msg, nil
	case *cluster.GrainErrorResponse:
		if msg == nil {
			return nil, nil
		}
		return nil, msg
	default:
		return nil, fmt.Errorf("unknown response type %T", resp)
	}
}

// CompleteCompetition requests the execution on to the cluster with CallOptions
func (g *PlayerGrainClient) CompleteCompetition(r *None, opts ...cluster.GrainCallOption) (*None, error) {
	if g.cluster.Config.RequestLog {
		g.cluster.Logger().Info("Requesting", slog.String("identity", g.Identity), slog.String("kind", "Player"), slog.String("method", "CompleteCompetition"), slog.Any("request", r))
	}
	bytes, err := proto.Marshal(r)
	if err != nil {
		return nil, err
	}
	reqMsg := &cluster.GrainRequest{MethodIndex: 4, MessageData: bytes}
	resp, err := g.cluster.Request(g.Identity, "Player", reqMsg, opts...)
	if err != nil {
		return nil, fmt.Errorf("error request: %w", err)
	}
	switch msg := resp.(type) {
	case *None:
		return msg, nil
	case *cluster.GrainErrorResponse:
		if msg == nil {
			return nil, nil
		}
		return nil, msg
	default:
		return nil, fmt.Errorf("unknown response type %T", resp)
	}
}

// PlayerActor represents the actor structure
type PlayerActor struct {
	ctx     cluster.GrainContext
	inner   Player
	Timeout time.Duration
}

// Receive ensures the lifecycle of the actor for the received message
func (a *PlayerActor) Receive(ctx actor.Context) {
	switch msg := ctx.Message().(type) {
	case *actor.Started: //pass
	case *cluster.ClusterInit:
		a.ctx = cluster.NewGrainContext(ctx, msg.Identity, msg.Cluster)
		a.inner = xPlayerFactory()
		a.inner.Init(a.ctx)

		if a.Timeout > 0 {
			ctx.SetReceiveTimeout(a.Timeout)
		}
	case *actor.ReceiveTimeout:
		ctx.Poison(ctx.Self())
	case *actor.Stopped:
		a.inner.Terminate(a.ctx)
	case actor.AutoReceiveMessage: // pass
	case actor.SystemMessage: // pass

	case *cluster.GrainRequest:
		switch msg.MethodIndex {
		case 0:
			req := &JoinRequest{}
			err := proto.Unmarshal(msg.MessageData, req)
			if err != nil {
				ctx.Logger().Error("[Grain] Join(JoinRequest) proto.Unmarshal failed.", slog.Any("error", err))
				resp := cluster.NewGrainErrorResponse(cluster.ErrorReason_INVALID_ARGUMENT, err.Error()).
					WithMetadata(map[string]string{
						"argument": req.String(),
					})
				ctx.Respond(resp)
				return
			}

			r0, err := a.inner.Join(req, a.ctx)
			if err != nil {
				resp := cluster.FromError(err)
				ctx.Respond(resp)
				return
			}
			ctx.Respond(r0)
		case 1:
			req := &StartCompetitionRequest{}
			err := proto.Unmarshal(msg.MessageData, req)
			if err != nil {
				ctx.Logger().Error("[Grain] StartCompetition(StartCompetitionRequest) proto.Unmarshal failed.", slog.Any("error", err))
				resp := cluster.NewGrainErrorResponse(cluster.ErrorReason_INVALID_ARGUMENT, err.Error()).
					WithMetadata(map[string]string{
						"argument": req.String(),
					})
				ctx.Respond(resp)
				return
			}

			r0, err := a.inner.StartCompetition(req, a.ctx)
			if err != nil {
				resp := cluster.FromError(err)
				ctx.Respond(resp)
				return
			}
			ctx.Respond(r0)
		case 2:
			req := &None{}
			err := proto.Unmarshal(msg.MessageData, req)
			if err != nil {
				ctx.Logger().Error("[Grain] WaitingExpired(None) proto.Unmarshal failed.", slog.Any("error", err))
				resp := cluster.NewGrainErrorResponse(cluster.ErrorReason_INVALID_ARGUMENT, err.Error()).
					WithMetadata(map[string]string{
						"argument": req.String(),
					})
				ctx.Respond(resp)
				return
			}

			r0, err := a.inner.WaitingExpired(req, a.ctx)
			if err != nil {
				resp := cluster.FromError(err)
				ctx.Respond(resp)
				return
			}
			ctx.Respond(r0)
		case 3:
			req := &AddScoresRequest{}
			err := proto.Unmarshal(msg.MessageData, req)
			if err != nil {
				ctx.Logger().Error("[Grain] AddScores(AddScoresRequest) proto.Unmarshal failed.", slog.Any("error", err))
				resp := cluster.NewGrainErrorResponse(cluster.ErrorReason_INVALID_ARGUMENT, err.Error()).
					WithMetadata(map[string]string{
						"argument": req.String(),
					})
				ctx.Respond(resp)
				return
			}

			r0, err := a.inner.AddScores(req, a.ctx)
			if err != nil {
				resp := cluster.FromError(err)
				ctx.Respond(resp)
				return
			}
			ctx.Respond(r0)
		case 4:
			req := &None{}
			err := proto.Unmarshal(msg.MessageData, req)
			if err != nil {
				ctx.Logger().Error("[Grain] CompleteCompetition(None) proto.Unmarshal failed.", slog.Any("error", err))
				resp := cluster.NewGrainErrorResponse(cluster.ErrorReason_INVALID_ARGUMENT, err.Error()).
					WithMetadata(map[string]string{
						"argument": req.String(),
					})
				ctx.Respond(resp)
				return
			}

			r0, err := a.inner.CompleteCompetition(req, a.ctx)
			if err != nil {
				resp := cluster.FromError(err)
				ctx.Respond(resp)
				return
			}
			ctx.Respond(r0)
		}
	default:
		a.inner.ReceiveDefault(a.ctx)
	}
}

// onError should be used in ctx.ReenterAfter
// you can just return error in reenterable method for other errors
func (a *PlayerActor) onError(err error) {
	resp := cluster.FromError(err)
	a.ctx.Respond(resp)
}

var xGatekeeperFactory func() Gatekeeper

// GatekeeperFactory produces a Gatekeeper
func GatekeeperFactory(factory func() Gatekeeper) {
	xGatekeeperFactory = factory
}

// GetGatekeeperGrainClient instantiates a new GatekeeperGrainClient with given Identity
func GetGatekeeperGrainClient(c *cluster.Cluster, id string) *GatekeeperGrainClient {
	if c == nil {
		panic(fmt.Errorf("nil cluster instance"))
	}
	if id == "" {
		panic(fmt.Errorf("empty id"))
	}
	return &GatekeeperGrainClient{Identity: id, cluster: c}
}

// GetGatekeeperKind instantiates a new cluster.Kind for Gatekeeper
func GetGatekeeperKind(opts ...actor.PropsOption) *cluster.Kind {
	props := actor.PropsFromProducer(func() actor.Actor {
		return &GatekeeperActor{
			Timeout: 60 * time.Second,
		}
	}, opts...)
	kind := cluster.NewKind("Gatekeeper", props)
	return kind
}

// GetGatekeeperKind instantiates a new cluster.Kind for Gatekeeper
func NewGatekeeperKind(factory func() Gatekeeper, timeout time.Duration, opts ...actor.PropsOption) *cluster.Kind {
	xGatekeeperFactory = factory
	props := actor.PropsFromProducer(func() actor.Actor {
		return &GatekeeperActor{
			Timeout: timeout,
		}
	}, opts...)
	kind := cluster.NewKind("Gatekeeper", props)
	return kind
}

// Gatekeeper interfaces the services available to the Gatekeeper
type Gatekeeper interface {
	Init(ctx cluster.GrainContext)
	Terminate(ctx cluster.GrainContext)
	ReceiveDefault(ctx cluster.GrainContext)
	Enqueue(req *EnqueueRequest, ctx cluster.GrainContext) (*None, error)
}

// GatekeeperGrainClient holds the base data for the GatekeeperGrain
type GatekeeperGrainClient struct {
	Identity string
	cluster  *cluster.Cluster
}

// Enqueue requests the execution on to the cluster with CallOptions
func (g *GatekeeperGrainClient) Enqueue(r *EnqueueRequest, opts ...cluster.GrainCallOption) (*None, error) {
	if g.cluster.Config.RequestLog {
		g.cluster.Logger().Info("Requesting", slog.String("identity", g.Identity), slog.String("kind", "Gatekeeper"), slog.String("method", "Enqueue"), slog.Any("request", r))
	}
	bytes, err := proto.Marshal(r)
	if err != nil {
		return nil, err
	}
	reqMsg := &cluster.GrainRequest{MethodIndex: 0, MessageData: bytes}
	resp, err := g.cluster.Request(g.Identity, "Gatekeeper", reqMsg, opts...)
	if err != nil {
		return nil, fmt.Errorf("error request: %w", err)
	}
	switch msg := resp.(type) {
	case *None:
		return msg, nil
	case *cluster.GrainErrorResponse:
		if msg == nil {
			return nil, nil
		}
		return nil, msg
	default:
		return nil, fmt.Errorf("unknown response type %T", resp)
	}
}

// GatekeeperActor represents the actor structure
type GatekeeperActor struct {
	ctx     cluster.GrainContext
	inner   Gatekeeper
	Timeout time.Duration
}

// Receive ensures the lifecycle of the actor for the received message
func (a *GatekeeperActor) Receive(ctx actor.Context) {
	switch msg := ctx.Message().(type) {
	case *actor.Started: //pass
	case *cluster.ClusterInit:
		a.ctx = cluster.NewGrainContext(ctx, msg.Identity, msg.Cluster)
		a.inner = xGatekeeperFactory()
		a.inner.Init(a.ctx)

		if a.Timeout > 0 {
			ctx.SetReceiveTimeout(a.Timeout)
		}
	case *actor.ReceiveTimeout:
		ctx.Poison(ctx.Self())
	case *actor.Stopped:
		a.inner.Terminate(a.ctx)
	case actor.AutoReceiveMessage: // pass
	case actor.SystemMessage: // pass

	case *cluster.GrainRequest:
		switch msg.MethodIndex {
		case 0:
			req := &EnqueueRequest{}
			err := proto.Unmarshal(msg.MessageData, req)
			if err != nil {
				ctx.Logger().Error("[Grain] Enqueue(EnqueueRequest) proto.Unmarshal failed.", slog.Any("error", err))
				resp := cluster.NewGrainErrorResponse(cluster.ErrorReason_INVALID_ARGUMENT, err.Error()).
					WithMetadata(map[string]string{
						"argument": req.String(),
					})
				ctx.Respond(resp)
				return
			}

			r0, err := a.inner.Enqueue(req, a.ctx)
			if err != nil {
				resp := cluster.FromError(err)
				ctx.Respond(resp)
				return
			}
			ctx.Respond(r0)
		}
	default:
		a.inner.ReceiveDefault(a.ctx)
	}
}

// onError should be used in ctx.ReenterAfter
// you can just return error in reenterable method for other errors
func (a *GatekeeperActor) onError(err error) {
	resp := cluster.FromError(err)
	a.ctx.Respond(resp)
}

var xCompetitionFactory func() Competition

// CompetitionFactory produces a Competition
func CompetitionFactory(factory func() Competition) {
	xCompetitionFactory = factory
}

// GetCompetitionGrainClient instantiates a new CompetitionGrainClient with given Identity
func GetCompetitionGrainClient(c *cluster.Cluster, id string) *CompetitionGrainClient {
	if c == nil {
		panic(fmt.Errorf("nil cluster instance"))
	}
	if id == "" {
		panic(fmt.Errorf("empty id"))
	}
	return &CompetitionGrainClient{Identity: id, cluster: c}
}

// GetCompetitionKind instantiates a new cluster.Kind for Competition
func GetCompetitionKind(opts ...actor.PropsOption) *cluster.Kind {
	props := actor.PropsFromProducer(func() actor.Actor {
		return &CompetitionActor{
			Timeout: 60 * time.Second,
		}
	}, opts...)
	kind := cluster.NewKind("Competition", props)
	return kind
}

// GetCompetitionKind instantiates a new cluster.Kind for Competition
func NewCompetitionKind(factory func() Competition, timeout time.Duration, opts ...actor.PropsOption) *cluster.Kind {
	xCompetitionFactory = factory
	props := actor.PropsFromProducer(func() actor.Actor {
		return &CompetitionActor{
			Timeout: timeout,
		}
	}, opts...)
	kind := cluster.NewKind("Competition", props)
	return kind
}

// Competition interfaces the services available to the Competition
type Competition interface {
	Init(ctx cluster.GrainContext)
	Terminate(ctx cluster.GrainContext)
	ReceiveDefault(ctx cluster.GrainContext)
	Start(req *StartRequest, ctx cluster.GrainContext) (*None, error)
	AddScores(req *AddPlayerScoresRequest, ctx cluster.GrainContext) (*None, error)
}

// CompetitionGrainClient holds the base data for the CompetitionGrain
type CompetitionGrainClient struct {
	Identity string
	cluster  *cluster.Cluster
}

// Start requests the execution on to the cluster with CallOptions
func (g *CompetitionGrainClient) Start(r *StartRequest, opts ...cluster.GrainCallOption) (*None, error) {
	if g.cluster.Config.RequestLog {
		g.cluster.Logger().Info("Requesting", slog.String("identity", g.Identity), slog.String("kind", "Competition"), slog.String("method", "Start"), slog.Any("request", r))
	}
	bytes, err := proto.Marshal(r)
	if err != nil {
		return nil, err
	}
	reqMsg := &cluster.GrainRequest{MethodIndex: 0, MessageData: bytes}
	resp, err := g.cluster.Request(g.Identity, "Competition", reqMsg, opts...)
	if err != nil {
		return nil, fmt.Errorf("error request: %w", err)
	}
	switch msg := resp.(type) {
	case *None:
		return msg, nil
	case *cluster.GrainErrorResponse:
		if msg == nil {
			return nil, nil
		}
		return nil, msg
	default:
		return nil, fmt.Errorf("unknown response type %T", resp)
	}
}

// AddScores requests the execution on to the cluster with CallOptions
func (g *CompetitionGrainClient) AddScores(r *AddPlayerScoresRequest, opts ...cluster.GrainCallOption) (*None, error) {
	if g.cluster.Config.RequestLog {
		g.cluster.Logger().Info("Requesting", slog.String("identity", g.Identity), slog.String("kind", "Competition"), slog.String("method", "AddScores"), slog.Any("request", r))
	}
	bytes, err := proto.Marshal(r)
	if err != nil {
		return nil, err
	}
	reqMsg := &cluster.GrainRequest{MethodIndex: 1, MessageData: bytes}
	resp, err := g.cluster.Request(g.Identity, "Competition", reqMsg, opts...)
	if err != nil {
		return nil, fmt.Errorf("error request: %w", err)
	}
	switch msg := resp.(type) {
	case *None:
		return msg, nil
	case *cluster.GrainErrorResponse:
		if msg == nil {
			return nil, nil
		}
		return nil, msg
	default:
		return nil, fmt.Errorf("unknown response type %T", resp)
	}
}

// CompetitionActor represents the actor structure
type CompetitionActor struct {
	ctx     cluster.GrainContext
	inner   Competition
	Timeout time.Duration
}

// Receive ensures the lifecycle of the actor for the received message
func (a *CompetitionActor) Receive(ctx actor.Context) {
	switch msg := ctx.Message().(type) {
	case *actor.Started: //pass
	case *cluster.ClusterInit:
		a.ctx = cluster.NewGrainContext(ctx, msg.Identity, msg.Cluster)
		a.inner = xCompetitionFactory()
		a.inner.Init(a.ctx)

		if a.Timeout > 0 {
			ctx.SetReceiveTimeout(a.Timeout)
		}
	case *actor.ReceiveTimeout:
		ctx.Poison(ctx.Self())
	case *actor.Stopped:
		a.inner.Terminate(a.ctx)
	case actor.AutoReceiveMessage: // pass
	case actor.SystemMessage: // pass

	case *cluster.GrainRequest:
		switch msg.MethodIndex {
		case 0:
			req := &StartRequest{}
			err := proto.Unmarshal(msg.MessageData, req)
			if err != nil {
				ctx.Logger().Error("[Grain] Start(StartRequest) proto.Unmarshal failed.", slog.Any("error", err))
				resp := cluster.NewGrainErrorResponse(cluster.ErrorReason_INVALID_ARGUMENT, err.Error()).
					WithMetadata(map[string]string{
						"argument": req.String(),
					})
				ctx.Respond(resp)
				return
			}

			r0, err := a.inner.Start(req, a.ctx)
			if err != nil {
				resp := cluster.FromError(err)
				ctx.Respond(resp)
				return
			}
			ctx.Respond(r0)
		case 1:
			req := &AddPlayerScoresRequest{}
			err := proto.Unmarshal(msg.MessageData, req)
			if err != nil {
				ctx.Logger().Error("[Grain] AddScores(AddPlayerScoresRequest) proto.Unmarshal failed.", slog.Any("error", err))
				resp := cluster.NewGrainErrorResponse(cluster.ErrorReason_INVALID_ARGUMENT, err.Error()).
					WithMetadata(map[string]string{
						"argument": req.String(),
					})
				ctx.Respond(resp)
				return
			}

			r0, err := a.inner.AddScores(req, a.ctx)
			if err != nil {
				resp := cluster.FromError(err)
				ctx.Respond(resp)
				return
			}
			ctx.Respond(r0)
		}
	default:
		a.inner.ReceiveDefault(a.ctx)
	}
}

// onError should be used in ctx.ReenterAfter
// you can just return error in reenterable method for other errors
func (a *CompetitionActor) onError(err error) {
	resp := cluster.FromError(err)
	a.ctx.Respond(resp)
}

func respond[T proto.Message](ctx cluster.GrainContext) func(T) {
	return func(resp T) {
		ctx.Respond(resp)
	}
}
